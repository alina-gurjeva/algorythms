"""
1. Подсчитать, сколько было выделено памяти под переменные в ранее разработанных программах
в рамках первых трех уроков. Проанализировать результат и определить программы с наиболее
эффективным использованием памяти.
Примечание: Для анализа возьмите любые 1-3 ваших программы или несколько вариантов кода
для одной и той же задачи. Результаты анализа вставьте в виде комментариев к коду.
Также укажите в комментариях версию Python и разрядность вашей ОС.
"""
import sys

"""
Согласно уточнению на лекции следует:
- взять любую задачу из прошлых дз
- написать еще 2 варианта решения и измерить память для 3х вариантов,
- в комментарии вывести результат
- написать вывод.

УТОЧНЕНИЕ: как я поняла, нужно посчитать память на переменные на МОМЕНТ вывода программы.
то есть переменные например при генерации списка: [i for i in range(1, 100)] - i не учитывать,
т.к. его съест сборщик мусора к моменту вывода результата программы.

Разрядность ОС: 64,
Версия Python: 3.9
"""


def count_bytes(obj):
    """
    counts bytes for object
    :param obj: variable
    :return all_q_bytes: how mach bytes the object is
    """
    all_q_bytes = 0

    def _count_bytes(obj):
        nonlocal all_q_bytes
        all_q_bytes += sys.getsizeof(obj)
        if hasattr(obj, '__iter__'):
            if hasattr(obj, 'items'):
                for k, v in obj.items():
                    _count_bytes(k)
                    _count_bytes(v)
            else:
                if len(obj) == 0:  # иначе функция зациклится при объекте строки
                    pass
                elif len(obj) == 1:  # иначе функция зациклится при объекте строки
                    all_q_bytes += sys.getsizeof(obj[0])
                else:
                    for it in obj:
                        _count_bytes(it)

    _count_bytes(obj)
    return all_q_bytes


"""
Задача взята из 1 урока: Найти сумму и произведение цифр трехзначного числа, которое вводит пользователь.
"""

# 1е решение было таким:

a = int(input('Введите целое 3х-значное число: '))  # 123
a1, a2, a3 = a // 100, a//10 % 10, a % 10
print(f'Сумма: {a1 + a2 + a3}, Произведение: {a1 * a2 * a3}')

# Считаем bytes
size_1_decision = 0
size_1_decision += count_bytes(a)
size_1_decision += count_bytes(a1)
size_1_decision += count_bytes(a2)
size_1_decision += count_bytes(a3)
print(size_1_decision)
# Вывод:
"""
112
"""

# Второе решение:
from functools import reduce

arr = [int(i) for i in input('Введите целое 3х-значное число: ')]
print(f'Сумма: {sum(arr)}, Произведение: {reduce((lambda x, y: x * y), arr)}')

# Считаем bytes
size_2_decision = 0
size_2_decision += count_bytes(a)
size_2_decision += count_bytes(arr)
print(size_2_decision)

# Вывод:
"""
200

# На самом деле, из условия неясно, надо ли итерироваться и считать дополнительную память
для объекта str типа a = '123' или для объекта a = [1,2,3] - т.к. внутри этих объектов все же не 
переменные. Если все же не надо, то для этого решения сумма будет всего 

116
"""


# 3 решение:

a = input('Введите целое 3х-значное число: ')
prod = 1
sum_a = 0
for x in a:
    prod *= int(x)
    sum_a += int(x)
print(f'Сумма: {sum_a}, Произведение: {prod}')

# Считаем bytes
size_3_decision = 0
size_3_decision += count_bytes(a)
size_3_decision += count_bytes(prod)
size_3_decision += count_bytes(sum_a)
size_3_decision += count_bytes(x)  # x еще останется в памяти как последний элемент a
print(size_3_decision)
# Вывод:
"""
508  

# На самом деле, из условия неясно, надо ли итерироваться и считать дополнительную память
для объекта str типа a = '123' или для объекта a = [1,2,3] - т.к. внутри этих объектов все же не 
переменные. Если все же не надо, то для этого решения сумма будет всего 

150
"""

# Общий вывод
"""
Наиболее эффективным оказалось 1е решение, без создания итерируемых объектов.
"""
